module Brainfuck where

import Data.List
import Data.Maybe

data Expression
    = Const Int             --arg0
    | Var Int Int           --p[arg0] * arg1
    | Sum Int [(Int, Int)]  --arg0 + p[arg1[0].0] * arg1[0].1 + p[arg1[1].0] * arg1[1].1 + ...
    deriving(Eq)

instance Show Expression where
    show (Const x)      = show x
    show (Var off val)  = showVar off val
    show (Sum val vars)
        | null vars     = valStr
        | val == 0      = varsStr
        | otherwise     = varsStr ++ " + " ++ valStr
        where
            valStr      = show val
            varsStr     = intercalate " + " $ map (uncurry showVar) vars

data Statement
    = Add Int Expression    -- p[arg0] += arg1
    | Set Int Expression    -- p[arg0] = arg1
    | Shift Int             -- p += arg
    | Loop Int [Statement]  -- while(p[arg0]) { arg1 }
    | Input Int             -- p[arg0] = getchar()
    | Output Expression     -- putchar(p[arg0])
    | Print String          -- puts(arg0) --only generated by ConstantFold
    | Comment String        -- /*arg0*/
    deriving(Eq)

instance Show Statement where
    show (Add off val)  = "p[" ++ (show off) ++ "] += " ++ (show val)
    show (Shift x)      = "p += " ++ (show x)
    show (Set off val)  = "p[" ++ (show off) ++ "] = " ++ (show val)
    show (Loop off c)   = "while(p[" ++ (show off) ++ "]) { " ++ (intercalate "; " $ map show c) ++ " }"
    show (Input off)    = "p[" ++ (show off) ++ "] = getchar()"
    show (Output val)   = "putchar(" ++ (show val) ++ ")"
    show (Print str)    = "puts(" ++ (show str) ++ ")"
    show (Comment str)  = "/*" ++ str ++ "*/"

isLoop (Loop _ _)       = True
isLoop _                = False

isComment (Comment _)   = True
isComment _             = False

showVar off val         = if val == 1
    then "p[" ++ (show off) ++ "]"
    else "p[" ++ (show off) ++ "] * " ++ (show val)

addExpressions expr1 expr2
    | null vars                     = Const val
    | val == 0 && length vars == 1  = Var (fst $ head vars) (snd $ head vars)
    | otherwise                     = Sum val vars
    where
        exprToSum expr              = case expr of
            Const val               -> (val, [])
            Var off mul             -> (0, [(off, mul)])
            Sum val vars            -> (val, vars)
        (val1, vars1)               = exprToSum expr1
        (val2, vars2)               = exprToSum expr2
        val                         = val1 + val2
        vars                        = vars1 ++ vars2

isZeroShift statements              = all isJust vals && valSum == 0
    where
        vals                        = map getShift statements
        valSum                      = sum $ catMaybes vals
        getShift (Shift val)        = Just val
        getShift (Loop _ children)  = if isZeroShift children
            then Just 0
            else Nothing
        getShift _                  = Just 0

parseStatements str     = fst $ parseStatements' str

parseStatements' []     = ([], [])
parseStatements' (x:xs)
    | x == ']'          = ([], xs)
    | x == '['          = ((Loop 0 rest) : rest', xs'')
    | otherwise         = (curr : rest, xs')
    where
        curr            = case x of
            '+'         -> Add 0 (Const 1)
            '-'         -> Add 0 (Const (-1))
            '>'         -> Shift 1
            '<'         -> Shift (-1)
            ','         -> Input 0
            '.'         -> Output (Var 0 1)
            _           -> Comment [x]
        (rest, xs')     = parseStatements' xs
        (rest', xs'')   = parseStatements' xs'
